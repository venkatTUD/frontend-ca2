name: Frontend Blue-Green Deployment to Prod
on:
  push:
    branches: ["main"]
  pull_request:
    branches: ["main"]
env:
  IMAGE_NAME: receipt-frontend
  DOCKER_REGISTRY: docker.io
  GKE_CLUSTER_NAME: receipt-prod-cluster
  GKE_REGION: us-central1
  SERVICE_NAME: receipt-frontend-service
  NAMESPACE: prod
jobs:
  deploy-frontend:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Get short SHA
        id: sha
        run: echo "SHORT_SHA=$(git rev-parse --short HEAD)" >> $GITHUB_ENV

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERID }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build and push frontend
        uses: docker/build-push-action@v6
        with:
          context: .
          file: Dockerfile
          push: true
          tags: venkatakurathitud/${{ env.IMAGE_NAME }}:${{ env.SHORT_SHA }}
          cache-from: type=gha
          cache-to: type=gha,mode=max

      - name: Authenticate to Google Cloud
        uses: google-github-actions/auth@v1
        with:
          credentials_json: ${{ secrets.GCP_CREDENTIALS }}

      - name: Set up gcloud
        uses: google-github-actions/setup-gcloud@v1
        with:
          project_id: eadtud
          install_components: 'gke-gcloud-auth-plugin'

      - name: Configure kubectl
        run: |
          gcloud container clusters get-credentials $GKE_CLUSTER_NAME --region $GKE_REGION

      - name: Initial Deployment Setup
        id: initial-setup
        run: |
          if ! kubectl get svc ${{ env.SERVICE_NAME }} -n ${{ env.NAMESPACE }} --ignore-not-found; then
            echo "Frontend service not found. Performing initial deployment setup."
            kubectl apply -f k8s/base/deployment-blue.yaml -n ${{ env.NAMESPACE }}
            kubectl apply -f k8s/base/deployment-green.yaml -n ${{ env.NAMESPACE }}
            kubectl scale deployment/receipt-frontend-blue --replicas=0 -n ${{ env.NAMESPACE }}
            kubectl scale deployment/receipt-frontend-green --replicas=0 -n ${{ env.NAMESPACE }}
            kubectl apply -f k8s/base/service.yaml -n ${{ env.NAMESPACE }}
            echo "Initial setup complete. Service and deployments created."
            echo "IS_INITIAL_SETUP=true" >> $GITHUB_ENV
          else
            echo "Frontend service found. Skipping initial setup."
            echo "IS_INITIAL_SETUP=false" >> $GITHUB_ENV
          fi

      - name: Determine active environment
        id: get-active-env
        run: |
          if kubectl get svc ${{ env.SERVICE_NAME }} -n ${{ env.NAMESPACE }} -o jsonpath='{.spec.selector.env}' &> /dev/null; then
             ACTIVE_ENV=$(kubectl get svc ${{ env.SERVICE_NAME }} -n ${{ env.NAMESPACE }} -o jsonpath='{.spec.selector.env}')
             echo "Detected active environment: $ACTIVE_ENV"
          else
             echo "Could not determine active environment from service selector. Assuming 'blue' will be the next inactive environment."
             ACTIVE_ENV="green"
          fi

          if [ "$ACTIVE_ENV" = "blue" ]; then
            echo "INACTIVE_ENV=green" >> $GITHUB_ENV
            echo "ACTIVE_ENV=blue" >> $GITHUB_ENV
          else
            echo "INACTIVE_ENV=blue" >> $GITHUB_ENV
            echo "ACTIVE_ENV=green" >> $GITHUB_ENV
          fi
          echo "INACTIVE_ENV=${{ env.INACTIVE_ENV }}"
          echo "ACTIVE_ENV=${{ env.ACTIVE_ENV }}"


      - name: Deploy to inactive environment (with Debugging)
        if: env.IS_INITIAL_SETUP == 'false'
        run: |
          echo "Deploying to inactive environment: ${{ env.INACTIVE_ENV }}"
          cd k8s/overlays/prod

          # --- Debugging Step 1: Print base deployment files ---
          echo "--- Content of k8s/base/deployment-blue.yaml ---"
          cat ../../base/deployment-blue.yaml
          echo "--- End of k8s/base/deployment-blue.yaml ---"
          echo "--- Content of k8s/base/deployment-green.yaml ---"
          cat ../../base/deployment-green.yaml
          echo "--- End of k8s/base/deployment-green.yaml ---"
          # ----------------------------------------------------

          echo "Setting image tag in kustomization.yaml..."
          kustomize edit set image venkatakurathitud/receipt-frontend=venkatakurathitud/receipt-frontend:${{ env.SHORT_SHA }}
          echo "Image tag set."

          # --- Debugging Step 2: Print the generated kustomized YAML ---
          echo "--- Kustomize Build Output ---"
          kustomize build .
          echo "--- End of Kustomize Build Output ---"
          # ----------------------------------------------------------

          echo "Applying kustomized configuration..."
          kubectl apply -k .
          echo "Deployment manifest updated and applied for ${{ env.INACTIVE_ENV }}."

      - name: Setup jq for JSON parsing
        run: sudo apt-get install -y jq

      - name: Test inactive environment and Scale Up
        run: |
            echo "### Starting deployment verification and scale up ###"

            if [ "${{ env.IS_INITIAL_SETUP }}" = "true" ]; then
              echo "üÜï Initial setup detected - scaling up green deployment."
              kubectl scale deployment/receipt-frontend-green --replicas=1 -n ${{ env.NAMESPACE }}
              echo "üéØ Green deployment scaled up for initial traffic."
              kubectl wait deployment/receipt-frontend-green -n ${{ env.NAMESPACE }} --for condition=available --timeout=300s
              echo "Initial green deployment is ready."
              exit 0
            fi

            echo "üîÅ Normal deployment flow - testing and scaling inactive environment: ${{ env.INACTIVE_ENV }}"
            echo "Scaling up deployment/receipt-frontend-${{ env.INACTIVE_ENV }} to 1 replica."
            kubectl scale deployment/receipt-frontend-${{ env.INACTIVE_ENV }} --replicas=1 -n ${{ env.NAMESPACE }}
            echo "Waiting for deployment/receipt-frontend-${{ env.INACTIVE_ENV }} to become available..."
            kubectl wait deployment/receipt-frontend-${{ env.INACTIVE_ENV }} -n ${{ env.NAMESPACE }} --for condition=available --timeout=300s
            echo "Deployment ${{ env.INACTIVE_ENV }} is available."

            FRONTEND_POD=""
            for i in {1..20}; do
              FRONTEND_POD=$(kubectl get pods -l app=receipt-frontend,env=${{ env.INACTIVE_ENV }} -n ${{ env.NAMESPACE }} --field-selector=status.phase=Running -o jsonpath='{.items[0].metadata.name}' 2>/dev/null)
              if [ -n "$FRONTEND_POD" ]; then
                echo "‚úÖ Found running pod: $FRONTEND_POD"
                break
              elif [ "$i" -eq 20 ]; then
                echo "‚ùå ERROR: No running pod found for ${{ env.INACTIVE_ENV }} after 20 attempts"
                kubectl get pods -l app=receipt-frontend -n ${{ env.NAMESPACE }} -o wide
                exit 1
              else
                echo "‚åõ Waiting for pod to start for ${{ env.INACTIVE_ENV }} (attempt $i/20)..."
                sleep 10
              fi
            done

            echo "Performing health check on pod $FRONTEND_POD..."
            LOCAL_PORT=$(python -c 'import socket; s=socket.socket(); s.bind(("", 0)); print(s.getsockname()[1]); s.close()')
            echo "Using local port $LOCAL_PORT for port-forward."

            kubectl port-forward pod/$FRONTEND_POD $LOCAL_PORT:22137 -n ${{ env.NAMESPACE }} &
            PF_PID=$!
            sleep 10

            if ! ps -p $PF_PID > /dev/null; then
                echo "‚ùå ERROR: Port-forward process failed to start."
                exit 1
            fi

            HEALTH_CHECK_URL="http://localhost:$LOCAL_PORT/health"
            echo "Attempting health check on $HEALTH_CHECK_URL"

            if curl --retry 5 --retry-delay 5 --connect-timeout 5 --max-time 10 "$HEALTH_CHECK_URL"; then
              echo "‚úÖ Health check passed"
              kill $PF_PID
            else
              echo "‚ùå Health check failed"
              kill $PF_PID
              exit 1
            fi

            echo "üéâ Environment ${{ env.INACTIVE_ENV }} verified successfully"

      - name: Switch traffic to inactive environment
        if: env.IS_INITIAL_SETUP == 'false'
        run: |
          echo "Switching traffic from ${{ env.ACTIVE_ENV }} to ${{ env.INACTIVE_ENV }}"
          ./scripts/switch-blue-green.sh ${{ env.NAMESPACE }} ${{ env.INACTIVE_ENV }} ${{ env.ACTIVE_ENV }} ${{ env.SHORT_SHA }}
          echo "Traffic switched."

      - name: Verify deployment
        if: env.IS_INITIAL_SETUP == 'false'
        run: |
          echo "Verifying the newly active environment: ${{ env.INACTIVE_ENV }}"
          kubectl wait --for=condition=ready pod -l app=receipt-frontend,env=${{ env.INACTIVE_ENV }} -n ${{ env.NAMESPACE }} --timeout=300s
          echo "Service endpoints are ready for ${{ env.INACTIVE_ENV }}."

          EXTERNAL_IP=$(kubectl get svc ${{ env.SERVICE_NAME }} -n ${{ env.NAMESPACE }} -o jsonpath='{.status.loadBalancer.ingress[0].ip}' || echo "pending")
          if [ "$EXTERNAL_IP" = "pending" ]; then
            echo "External IP not available, skipping external verification"
            exit 0
          fi

          FRONTEND_URL="http://${EXTERNAL_IP}"
          echo "Performing external health checks on $FRONTEND_URL..."
          curl --fail --retry 10 --retry-delay 10 --connect-timeout 5 --max-time 15 "$FRONTEND_URL" || { echo "Warning: Frontend health check failed"; }
          curl --fail --retry 10 --retry-delay 10 --connect-timeout 5 --max-time 15 "$FRONTEND_URL/recipes" || { echo "Warning: Frontend-backend API health check failed"; }
          curl --fail --retry 10 --retry-delay 10 --connect-timeout 5 --max-time 15 "$FRONTEND_URL/metrics" || { echo "Warning: Frontend metrics endpoint check failed"; }

          echo "External verification complete."

